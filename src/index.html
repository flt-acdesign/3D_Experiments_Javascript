<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Babylon.js and Ammo.js Physics Scene</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcesses.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <!-- Ammo.js should be included here. It might be a direct script link or bundled with your app -->
    <script src="path_to_your_ammo.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>


/// please write a web page using babylon.js and ammo.js as the physics engine that creates a solid ground of color green and dimensions 1.27 m by 2.54 m, creates walls of color green and height 0.05 m on all the edges of the ground and parallel to the corresponding edge, creates three spheres of white color, diameter 0.062 m and mass 0.22 Kg. When the user clicks on the surface of one of the spheres, the clicked-on sphere will increase its velocity in 1.0 m/s in the direction parallel to a line going from the point of view of the camera to the point of intersection with the clicked sphere. The collisions between spheres have a restitution coefficient of 0.98. The collisions. between spheres and walls have a restitution coefficient of 0.98. The collisions between the spheres and the ground plane have a restitution coefficient of 0.8. The rolling friction coefficient between sphere and ground is 0.06. Add shadows to the scene, including shadows projected from the spheres to the ground plane. 

<script>
    window.addEventListener('DOMContentLoaded', function () {
        // Set up the basic engine and scene
        var canvas = document.getElementById('renderCanvas');
        var engine = new BABYLON.Engine(canvas, true);
        var scene = new BABYLON.Scene(engine);

        // Camera and light setup
        var camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 3, new BABYLON.Vector3(0, 0, 0), scene);
        camera.attachControl(canvas, true);
        var light = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(-1, -2, -1), scene);
        light.position = new BABYLON.Vector3(1, 2, 1);
        scene.clearColor = new BABYLON.Color3.White();

        // Physics setup with Ammo.js
        var gravityVector = new BABYLON.Vector3(0, -9.81, 0);
        var physicsPlugin = new BABYLON.AmmoJSPlugin();
        scene.enablePhysics(gravityVector, physicsPlugin);

        // Ground setup
        var groundSize = { width: 1.27, height: 2.54 };
        var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: groundSize.width, height: groundSize.height }, scene);
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        ground.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
        ground.receiveShadows = true;
        ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.8, friction: 0.06 }, scene);

        // Walls setup
        var wallHeight = 0.05;
        var wallOptions = { width: groundSize.width, height: wallHeight, depth: 0.1 };
        var wallPositions = [
            { x: 0, y: wallHeight / 2, z: groundSize.height / 2 }, // North
            { x: 0, y: wallHeight / 2, z: -groundSize.height / 2 }, // South
            { x: groundSize.width / 2, y: wallHeight / 2, z: 0 }, // East
            { x: -groundSize.width / 2, y: wallHeight / 2, z: 0 }  // West
        ];
        wallPositions.forEach(function (pos) {
            var wall = BABYLON.MeshBuilder.CreateBox("wall", wallOptions, scene);
            wall.position.set(pos.x, pos.y, pos.z);
            wall.material = new BABYLON.StandardMaterial("wallMat", scene);
            wall.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
            wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.98 }, scene);
        });

        // Sphere setup
        var sphereDiameter = 0.062;
        var sphereOptions = { diameter: sphereDiameter, segments: 32 };
        for (var i = 0; i < 3; i++) {
            var sphere = BABYLON.MeshBuilder.CreateSphere("sphere" + i, sphereOptions, scene);
            sphere.material = new BABYLON.StandardMaterial("sphereMat", scene);
            sphere.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
            sphere.position = new BABYLON.Vector3((i - 1) * sphereDiameter, sphereDiameter / 2, 0);
            sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0.22, restitution: 0.98 }, scene);

            // Shadows
            sphere.receiveShadows = true;
        }

        // Shadow generator
        var shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
        shadowGenerator.useExponentialShadowMap = true;
        shadowGenerator.addShadowCaster(scene.meshes);

        // Click event listener for spheres
        window.addEventListener("click", function (evt) {
            var pickResult = scene.pick(scene.pointerX, scene.pointerY);
            if (pickResult.hit && pickResult.pickedMesh.name.indexOf('sphere') === 0) {
                var direction = pickResult.pickedPoint.subtract(scene.activeCamera.position);
                direction = direction.normalize();
                pickResult.pickedMesh.physicsImpostor.applyImpulse(direction.scale(1), pickResult.pickedPoint);
            }
        });

        // Render loop
        engine.runRenderLoop(function () {
            scene.render();
        });

        // Resize event
        window.addEventListener("resize", function () {
            engine.resize();
        });
    });
</script>
</body>
</html>
